<html lang="en">
  <head>
    <meta charset="UTF-8"/>
    <title>Perkenalan ReasonML, Sintaks Baru untuk OCaml</title>

    <link rel="stylesheet" href="/assets/global.css" type="text/css" media="screen" />
    <link href="https://unpkg.com/prismjs@1.20.0/themes/prism-okaidia.css" rel="stylesheet">
    <link rel="stylesheet" href="/assets/tulisan.css" type="text/css" media="screen" />
  </head>
  <body>
      <h1>👋 <a class="color-blue" href="/">Saya Riza</a>!</h1>
      <h2>Perkenalan ReasonML, Sintaks Baru untuk OCaml</h2>
      <p>ReasonML adalah bahasa sintaks, ekstensi dan <em>toolchain</em> yang berada diatas sebuah bahasa <em>jadul</em> <a href="https://ocaml.org/">OCaml</a>. Selain dapat dikompilasi ke JavaScript dengan bantuan <a href="https://bucklescript.github.io/">BuckleScript</a>, Reason juga dapat dikompilasi menjadi aplikasi native melalui OCaml. Daripada membuat bahasa baru dari awal, tim Facebook memutuskan untuk membuat sintaks baru dan memperkaya <em>environment</em> OCaml sehingga menjadi lebih modern dan kekinian. OCaml sendiri sudah digunakan lebih dari 20 tahun dan sudah teruji oleh industri sejak tahun 90-an.</p>
<p>Jika melihat sintaks Reason saat ini sudah mirip dan menyerupai ES6. Lihat perbandingan dibawah ini antara sintaks OCaml, Reason versi awal dan Reason terbaru. Semakin baru, sintaks nya semaki mirip ES6 atau JavaScript modern.</p>
<p><img src="https://cdn-images-1.medium.com/max/3860/1*i4DqT6krOCc5JH9Fk9CpmQ.png" alt="Perbandingan sintaks OCaml, Reason lama, dan Reason terbaru."><em>Perbandingan sintaks OCaml, Reason lama, dan Reason terbaru.</em></p>
<h2>Kenapa Menggunakan Reason</h2>
<p>Ada beberapa alasan kenapa teman-teman perlu mempertimbangkan Reason sebagai platform yang layak untuk dipelajari. Selain proses kompilasi yang cepat dan sintaks yang familiar, ada beberapa keunggulan lainnya. Berikut beberapa diantaranya.</p>
<h3>Type System dan <em>Type Inference</em></h3>
<p>Seperti yang kita ketahui bersama, JavaScript bukanlah bahasa pemrograman yang memiliki <em>type system.</em> Dan semakin besar basis kode yang kita miliki akan semakin butuh kita akan <em>type system.</em> Makanya muncul beberapa solusi seperti TypeScript dan juga Flow.</p>
<p>TypeScript adalah sebuah bahasa pemrograman dari Microsoft yang merupakan <em>subset</em> dari JavaScript dengan menambahkan <em>type system</em>. Jadi kita sebenarnya tetap bisa menulis JavaScript didalam file-file TypeScript.</p>
<p>Begitu juga dengan Flow, sebuah <em>static type checker</em> untuk JavaScript yang juga berasal dari Facebook. Flow bertindak sebagai anotasi untuk kode JavaScript yang sudah ada. Uniknya, Flow dikembangkan menggunakan OCaml.</p>
<p>Dibandingkan dengan Reason? Pertama, Reason bukanlah sintaks baru untuk JavaScript. Reason adalah sintaks baru untuk OCaml, baru kemudian dari OCaml dikompilasi ke JavaScript. Kedua, fitur Reason lebih lengkap dan utamanya <em>type system</em> jauh lebih <strong>solid</strong> berkat OCaml.</p>
<p>Dan yang bikin Reason lebih keren lagi adalah fitur <em>type inference</em>-nya. Reason dapat menebak <em>type</em> dari kodingan kita tanpa harus mendefinisikan <em>type</em>-nya satu-per-satu. Dan fitur ini belum dapat ditandingi oleh TypeScript ataupun Flow. Mari kita lihat contohnya di rtop, REPL untuk Reason.</p>
<p><img src="https://cdn-images-1.medium.com/max/5760/1*nlpG7UlWXmAhIjF8FbgdyA.png" alt="Fungsi add menerima dua buah parameter integer dan fungsi add akan me-return integer juga."><em>Fungsi add menerima dua buah parameter integer dan fungsi add akan me-return integer juga.</em></p>
<p>Seperti bisa dilihat, kita membuat sebuah fungsi dengan nama add yang memiliki parameter a dan b dan menghasilkan penjumlahan a dengan b . Ketika mendeklarasikan fungsi add tersebut, kita tidak sama sekali mendefinisikan tipe data dari a, b dan juga hasil dari fungsi add. Akan tetapi setelah dievaluasi, menghasilkan kode berikut ini: <code>let add: (int, int) =&gt; int = &lt;fun&gt;;</code>. Artinya Reason dapat menebak bahwa tipe data a, b dan juga hasil dari add adalah integer.</p>
<p>Mari kita lihat satu contoh <em>type inference</em> lagi yang lebih keren dengan menggunakan struktur data records.</p>
<p><img src="https://cdn-images-1.medium.com/max/4612/1*GvIibB8iZCIUA2q879Bedg.png" alt="Reason mampu menebak records sesuai properti yang terkandung didalamnya."><em>Reason mampu menebak tipe records sesuai properti yang terkandung didalamnya.</em></p>
<p>Ketika kita mendefinisikan sebuah record, disarankan untuk memberi anotasi atau catatan untuk mengarahkan sebuah variable kepada tipenya. Misalnya <code>let kuririn : person = { age: 31, name: &quot;Kuririn&quot; };</code>. Disini kita mendefinisikan record baru dengan tipe person seperti yang sudah kita definisikan sebelumnya. Tetapi sebenarnya kita tidak perlu melakukannya, seperti variable chiChi dan piccolo, kita tidak mendefinisikan sebagai tipe person, Reason dapat membedakan tipenya berdasarkan properti yang didefinisikan. Karena chiChi tidak memiliki properti species, maka chiChi dikategorikan sebagai person. Sementara piccolo karena memiliki properti species, maka ia termasuk nonPerson.</p>
<h3>Pesan Kesalahan yang Manusiawi</h3>
<p>Dan karena <em>type system</em> yang solid, Reason dapat menampilkan pesan kesalahan yang cukup detil dan manusiawi. Kita kembali ke contoh fungsi add sebelumnya yang menerima dua parameter integer. Bagaimana jika kita memanggil fungsi tersebut dengan parameter integer dan string?</p>
<p><img src="https://cdn-images-1.medium.com/max/3596/1*3VpX4PwJLhVS7e5ag_droQ.png" alt="Pesan kesalahan yang detil dan manusiawi."><em>Pesan kesalahan yang detil dan manusiawi.</em></p>
<p>Dari pesan kesalahan diatas sudah cukup jelas bahwa string “7” merupakan sumber kesalahan, karena diharapkan integer bukan string.</p>
<p>Jika kita menggunakan JavaScript fungsi tersebut akan dieksekusi dengan baik, meskipun hasilnya salah, yaitu menjadi “67”.</p>
<p><img src="https://cdn-images-1.medium.com/max/2000/1*zTMnImlX1yGVpZmAjp1WhA.png" alt="Bukan pesan kesalahan yang kita dapatkan, akan tetapi bug yang akan muncul jika di JavaScript"></p>
<p><em>Bukan pesan kesalahan yang kita dapatkan, akan tetapi bug yang akan muncul jika di JavaScript</em></p>
<p>Hal ini cukup berbahaya, JavaScript dapat mengeksekusi pemanggilan fungsi diatas tanpa masalah, akan tetapi hasilnya nge-<em>bug</em>. Sebagai tambahan, Reason juga dapat mendeteksi <em>typo</em> atau kesalahan pengetikan. Bayangkan berapa banyak bugs dan <em>typo</em> yang dapat dihindari.</p>
<p><img src="https://cdn-images-1.medium.com/max/2000/1*6HeGFhbOkfMNG9saWV-FAA.png" alt="Mendeteksi Typo."><em>Mendeteksi Typo.</em></p>
<h3>Alat Bantu Yang Kompit</h3>
<p>Meskipun tergolong baru, Reason sudah dilengkapi dengan alat bantu yang tergolong komplit. Hal ini juga terbantu dengan keputusan untuk menggunakan beberapa alat bantu yang sudah ada seperti yarn/npm, babel, create-react-app dan webpack. Sehingga selain melengkapi alat bantu lain, developer yang sudah terbiasa menggunakan yarn/npm dan webpack menjadi lebih mudah mempelajari Reason.</p>
<p><img src="https://cdn-images-1.medium.com/max/3888/1*eqqXemwsvNxetgfUFemx1Q.png" alt="Reason ‘meminjam’ beberapa alat bantu yang sudah ada di ekosistem JavaScript"><em>Reason ‘meminjam’ beberapa alat bantu yang sudah ada di ekosistem JavaScript</em></p>
<h3>Kemudahan Adopsi dan Kemudahan Untuk Dikelola</h3>
<p>Reason berada di <em>sweet spot</em> antara kemudahan adopsi dan kemudahan untuk dikelola. Dengan sintaks yang lebih familiar, terutama bagi modern JavaScript developer, mempelajari Reason akan menjadi lebih lancar. Dan dengan bantuan Type System dan fitur-fitur lainnya, kemudahan <em>maintenance</em> pun dapat dicapai. Terutama dalam menghindari <em>bugs</em> dan kesalahan yang umum terjadi ketika <em>runtime</em> dipindah ke <em>compile time</em> sehingga pengguna tidak terkena dampaknya. Ketika kode Reason berhasil dikompilasi, artinya kode kita sudah terbebas dari *silly mistakes *seperti <em>typo</em> dan lain sebagainya. Jika tidak, maka proses kompilasi gagal.</p>
<p><img src="https://cdn-images-1.medium.com/max/3840/1*vktrkdYUCyeJQlTfvl7TUA.png" alt="Grid yang diadaptasi dari talk Jared Forsyth (https://jaredforsyth.com/)"><em>Grid yang diadaptasi dari <em>talk</em> Jared Forsyth (<a href="https://jaredforsyth.com/">https://jaredforsyth.com/</a>)</em></p>
<p>Seperti yang dapat dilihat dari ilustrasi diatas, JavaScript dan ES6 sangat mudah dipelajari. Lain halnya jika kita berbicara *maintenance *kode kita karena JavaScript tidak memiliki type system dan rentan <em>bugs</em> dan kesalahan. TypeScript masih cenderung mudah dipelajari dan diadopsi. Proses <em>maintenance</em> kodenya sendiri memang jauh lebih baik daripada JavaScript.</p>
<p>Dari sisi yang berbeda, maintenance kode di Haskell sangatlah mudah, bahkan jika sudah berjalan, kemungkinan besar kode Haskell tidak perlu dikelola lagi. Akan tetapi Haskell terkenal dengan bahasa yang sulit dimengerti dan dipelajari. Elm adalah versi <em>mainstream</em> dari Haskell yang juga merupakan bahasa pemrograman yang dapat dikompilasi ke JavaScript.</p>
<p>Reason berada diposisi yang cukup strategis dimana kemudahan adopsi masih bisa ditoleransi dan kemudahan <em>maintenance</em> juga masih tergolong cukup baik.</p>
<h3>Interopabilitas Dengan JavaScript</h3>
<p>Seperti yang sudah dijelaskan sebelumnya, Reason menggunakan beberapa alat bantu yang juga digunakan oleh JavaScript seperti yarn/npm dan juga webpack. Sehingga ‘jarak’ dengan JavaScript terbilang masih cukup dekat apabila dibandingkan dengan Elm, misalnya.</p>
<p>Elm, menggunakan ekosistem dan <em>packages</em> sendiri sehingga cukup menyulitkan apabila kita ingin memanfaatkan <em>library</em> yang sudah tersedia di npm. Sementara dengan Reason menggunakan <em>library</em> JavaScript masih sangat memungkinkan.</p>
<p><img src="https://cdn-images-1.medium.com/max/3212/1*zTSKdzAuvwzi61RQnUV47w.png" alt="Interopabilitas Reason dengan JavaScript masih cukup dekat."><em>Interopabilitas Reason dengan JavaScript masih cukup dekat.</em></p>
<h3>Komunitas Kecil Tapi Hangat</h3>
<p>Karena memang masih tergolong baru, komunitas Reason masih cukup kecil untuk ukuran kuantitas, akan tetapi sangat hangat dan fokus.</p>
<blockquote>
<p>“The community is small but very focused on delivering a better experience for developers.” <strong>Wojciech Bilicki</strong></p>
</blockquote>
<p>Ngga percaya, berikut saya sertakan buktinya. Seorang teman di Facebook mem-post foto ini. Identitas disamarkan, tentunya.</p>
<p><img src="https://cdn-images-1.medium.com/max/4148/1*gEXMwYk-7bq0LcPYBpHb8A.png" alt="Disapa oleh Leader Komunitas ketika baru join grup discord."><em>Disapa oleh Leader Komunitas ketika baru join grup discord.</em></p>
<p>Bayangkan, seorang <a href="https://twitter.com/_chenglou?lang=en">Cheng Lou</a>, yang me-<em>lead</em> project Reason punya waktu untuk <em>say hi</em> kepada seseorang yang baru join komunitas adalah sebuah sentuhan yang hangat.</p>
<h3>Bahasa Fungsional Yang Permisif</h3>
<p>Reason termasuk kedalam kategori bahasa fungsional nan deklaratif. Namun ia tidak melarang ketika kita ‘terpaksa’ menggunakan beberapa sintaks yang imperatif. Ketika kita kesulitan mendeklarasikan baris kode, kita masih dapat menggunakan <em>for loop</em> yang imperatif atau bahkan variable pun dapat kita buat <em>mutable</em>.</p>
<p><img src="https://cdn-images-1.medium.com/max/2240/1*RsJilTLJ3joLfNEZG9C1Gw.png" alt="Penggunaan mutable variable dan imperative loop."><em>Penggunaan mutable variable dan imperative loop.</em></p>
<p>Jadi misalnya kita sedang belajar functional programming tetapi belum menguasai sepenuhnya, Reason tidak akan menghentikanmu menulis kode yang imperatif seperti diatas, sehingga produktifitas tetap terjaga.</p>
<h2>Memulai Reason</h2>
<p>Untuk mulai menggunakan Reason, ada beberapa package yang kita butuhkan. Pertama, kita butuh reason-cli . Karena kita akan membuat aplikasi JavaScript di sisi client, kita juga butuh BuckleScript untuk melakukan kompilasi Reason atau OCaml ke JavaScript. Kedua <em>package</em> tersebut dapat kita install menggunakan yarn atau npm.</p>
<pre><code>$ yarn global add reason-cli
$ yarn global add bs-platform
</code></pre>
<p>Untuk membuat aplikasi sederhana, kita sekarang bisa menggunakan perintah:</p>
<pre class="language-shell"><code class="language-shell">    $ bsb -init nama-app -theme basic-reason<br>    $ <span class="token builtin class-name">cd</span> nama-app<br>    $ tree<br>    ./reason-demo/<br>    ├── .vscode<br>    ├── src<br>    │   └── Demo.re<br>    ├── .gitignore<br>    ├── README.md<br>    ├── bsconfig.json<br>    └── package.json</code></pre>
<p>Mari kita bahas satu-per-satu. Pertama ada folder src yang berisi kode Reason kita. Kemudian ada package.json yang merupakan daftar <em>dependencies</em> sama seperti project JavaScript ataupun NodeJS.</p>
<p><img src="https://cdn-images-1.medium.com/max/2200/1*HCeyWrc1lpvI30BpCB2dbQ.png" alt="Isi file package.json"><em>Isi file package.json</em></p>
<p>Yang berbeda adalah bsconfig.json yang berisi *dependencies *dan konfigurasi untuk Reason dan BuckleScript seperti definisi source direktori, pengaturan penamaan dan lain sebagainya.</p>
<p><img src="https://cdn-images-1.medium.com/max/2200/1*T-UkFOCEFuCCYB5WOTm6yA.png" alt="Isi file bsconfig.json"><em>Isi file bsconfig.json</em></p>
<p>Sekarang mari kita coba buka file src/Demo.re . Isinya kodenya cukup sederhana, sebuah pesan Hello World.</p>
<p><img src="https://cdn-images-1.medium.com/max/2240/1*G2-tutUVTQOX1K17E-2CCw.png" alt="Placeholder kode Demo.re"><em>Placeholder kode Demo.re</em></p>
<p>Sekedar informasi, semua modul yang menggunakan Js.* berasal dari BuckleScript. Contohnya Js.log, Js.Promise, Js.then_ dan lain sebagainya. Dan untuk melakukan kompilasi dari Reason menjadi JavaScript, kita tinggal menjalankan perintah berikut.</p>
<pre class="language-diff"><code class="language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   $ yarn build<br></span><span class="token prefix unchanged"> </span><span class="token line">   $ tree .<br></span><span class="token prefix unchanged"> </span><span class="token line">   .<br></span><span class="token prefix unchanged"> </span><span class="token line">   ├── .vscode<br></span><span class="token prefix unchanged"> </span><span class="token line">   ├── lib<br></span><span class="token prefix unchanged"> </span><span class="token line">   │   └── bs<br></span><span class="token prefix unchanged"> </span><span class="token line">   ├── src<br></span><span class="token prefix unchanged"> </span><span class="token line">   │   ├── Demo.bs.js<br></span><span class="token prefix unchanged"> </span><span class="token line">   │   └── Demo.re<br></span><span class="token prefix unchanged"> </span><span class="token line">   ├── .gitignore<br></span><span class="token prefix unchanged"> </span><span class="token line">   ├── .merlin<br></span><span class="token prefix unchanged"> </span><span class="token line">   ├── README.md<br></span><span class="token prefix unchanged"> </span><span class="token line">   ├── bsconfig.json<br></span><span class="token prefix unchanged"> </span><span class="token line">   └── package.json</code></pre>
<p>Dan sekarang sudah ada sebuah file baru, Demo.bs.js . Mari kita lihat isinya.</p>
<p><img src="https://cdn-images-1.medium.com/max/2240/1*p8VliE5_MXpqGOWqbtKKJw.png" alt="Hasil kompilasi BuckleScript"><em>Hasil kompilasi BuckleScript</em></p>
<p>Seperti yang sudah bisa kita tebak, hasilnya adalah console.log . Script ini kemudian dapat kita gabungkan dengan file html, misalnya seperti ini.</p>
<p><img src="https://cdn-images-1.medium.com/max/2240/1*8C-dM0qfhXlGmoH7vSExkA.png" alt="Load JavaScript file ke HTML"><em>Load JavaScript file ke HTML</em></p>
<p>Dan kita buka file tersebut di browser dan jangan lupa buka <em>chrome console</em> untuk melihat hasilnya.</p>
<p><img src="https://cdn-images-1.medium.com/max/3112/1*8ySipLVTgIAVtXWMgtZNRQ.png" alt="Dijalankan di browser"><em>Dijalankan di browser</em></p>
<p>Mari sekarang kita belajar sintaks Reason dengan membuat aplikasi perhitungan sederhana. Sekarang coba kita buat file baru src/Calc.re untuk membuat modul baru dengan nama Calc yang akan kita panggil nantinya dari src/Demo.re. Di Reason, file baru secara otomatis menjadi modul sendiri tanpa perlu export dan import. Mari lihat demonya.</p>
<h2>Mendeklarasikan Variable dan Fungsi</h2>
<p>Untuk mendeklarasikan fungsi di Reason, mirip sekali dengan notasi yang biasa kita lihat di JavaScript modern. Dengan menggunakan sintaks let diikuti dengan nama fungsinya, notasi = lalu kemudian diikuti dengan pendefinisian argumen atau parameter dan dilanjutkan dengan tanda <em>arrow</em> =&gt; terakhir diikuti dengan isi fungsinya. Jika isi fungsinya lebih dari satu baris, harus berada didalam <em>scope</em> dengan {}. Jika hanya satu baris tidak perlu menggunakan <em>scope {}.</em></p>
<p><img src="https://cdn-images-1.medium.com/max/2240/1*t8wSThN56mrG-q2smhNjYA.png" alt="Fungsi add di modul Calc"><em>Fungsi add di modul Calc</em></p>
<p>Untuk memanggil fungsi add dari file Demo.re kita bisa lakukan dengan cukup mudah. Kita bisa menggunakan notasi titik atau <em>dot</em>. Reason secara otomatis memahami bahwa fungsi add berada didalam file Calc.re ketika kita memanggil dengan cara Calc.add().</p>
<p>Dan semua proses deklarasi variable menggunakan let . Lebih luas, let di Reason juga digunakan untuk <em>scoping</em>, mendeklarasikan fungsi, *pattern matching *dan banyak lagi.</p>
<p><img src="https://cdn-images-1.medium.com/max/2240/1*LAU7t8wv9JrjB2mIjZnPyg.png" alt="Memanggil modul Calc dan fungsi add dari modul Demo."><em>Memanggil modul Calc dan fungsi add dari modul Demo.</em></p>
<p>Untuk menjalankannya kita bisa lakukan perintah yarn build terlebih dahulu untuk konversi Reason ke JavaScript baru kemudian file JavaScript-nya kita eksekusi atau buka di file index.html yang sebelumnya sudah kita buat.</p>
<p><img src="https://cdn-images-1.medium.com/max/2696/1*a-hgRCsAQNb1WktCrl7mIw.png" alt="Opps, error!"><em>Opps, error!</em></p>
<p>Wah, ada <em>error</em> di file Demo.bs.js di baris ke-empat. Mari kita lihat hasil konversinya.</p>
<p><img src="https://cdn-images-1.medium.com/max/2200/1*X1w2p1gQUCcFNBUmVjmLUg.png" alt="Error require di file Demo.bs.js"><em>Error require di file Demo.bs.js</em></p>
<p>Terjadi kesalahan di sintaks require. Hal ini terjadi karena browser belum mengerti sintaks exports dan juga require. Kita butuh bantuan <em>bundler</em> seperti webpack, rollup ataupun parcel agar browser dapat mengeksekusinya. Jika Demo.bs.js kita eksekusi di sisi backend dengan NodeJS, semua bisa berjalan normal karena NodeJS sudah mendukung sintaks require dan juga exports. Mari kita lihat.</p>
<p><img src="https://cdn-images-1.medium.com/max/2112/1*T9_NyXF8Gam1Z5-PuhZiNQ.png" alt="Di NodeJS aplikasi berjalan normal"><em>Di NodeJS aplikasi berjalan normal</em></p>
<p>Karena kita ingin eksekusi di browser, mari kita buat project baru dan kita gunakan parcel sebagai bundler. Alasannya, karena parcel menerapkan <em>zero-configuration</em> dibandingkan webpack yang harus melakukan konfigurasi terlebih dahulu. Jika belum, mari kita install parcel terlebih dahulu secara global dengan yarn atau npm. Kemudian kita akan buat folder baru untuk project kita dan buat file index.html.</p>
<pre><code>$ yarn global add parcel-bundler
$ mkdir reason-parcel
$ cd reason-parcel
</code></pre>
<p><img src="https://cdn-images-1.medium.com/max/2240/1*6IHWwR3-_poLDzukl0Vs0g.png" alt="File index.html"><em>File index.html</em></p>
<p>Buat juga file src/index.re dengan isi hello world terlebih dahulu untuk memastikan parcel berjalan sebagaimana mestinya. Kemudian untuk menjalankan, kita tinggal memanggil perintah parcel index.html.</p>
<p><img src="https://cdn-images-1.medium.com/max/2240/1*JKgqgN1dSIHGnUKPB3AIHg.png" alt="Placeholder index.re"><em>Placeholder index.re</em></p>
<p>Dan kita juga butuh file bsconfig.json sebagai penanda bahwa folder ini adalah project Reason. Kita samakan saja dengan konfigurasi di project sebelumnya.</p>
<p><img src="https://cdn-images-1.medium.com/max/2200/1*9ExqMLUETZQH39UDGilbCQ.png" alt="Konfigurasi bsconfig.json"><em>Konfigurasi bsconfig.json</em></p>
<p>Coba jalankan lagi perintah parcel index.html dan kemungkinan besar akan terjadi error karena project tidak mengetahui keberadaan package bs-platform yang kita install secara global sebelumnya. Dan dari pesan kesalahan seharusnya sudah cukup jelas apa yang harus kita lakukan selanjutnya.</p>
<p><img src="https://cdn-images-1.medium.com/max/4288/1*aB5Vpu42Gvtd1eTqqu2x8A.png" alt="Package bs-platform tidak ditemukan"><em>Package bs-platform tidak ditemukan</em></p>
<p>Kita tinggal menjalankan perintah npm link bs-platform sehingga npm akan me-<em>link</em> project ini ke package bs-platform yang sudah kita install secara global sebelumnya.</p>
<pre><code>$ npm link bs-platform
</code></pre>
<p>Jalankan lagi perintah parcel index.html dan aplikasi kita sudah berjalan di <a href="http://localhost:1234">http://localhost:1234</a> dan sudah dapat dibuka di browser dan mendapatkan pesan “Hello, world!” di browser console.</p>
<p><img src="https://cdn-images-1.medium.com/max/2000/1*FeU8LIKqPfWwkBslCb5DOw.png" alt="Parcel sudah berhasil menjalankan project Reason!"><em>Parcel sudah berhasil menjalankan project Reason!</em></p>
<p>Sip! Sekarang mari kita buat modul Calc seperti sebelumnya untuk memastikan dapat dieksekusi di browser dengan parcel. Agar berbeda dengan modul Calc sebelumnya, kali ini kita tambahkan <em>type annotation</em> biar lebih jelas dan akan berguna sebagai dokumentasi juga.</p>
<p><img src="https://cdn-images-1.medium.com/max/2240/1*2MPbvFjQLPv59EIt9f2Exw.png" alt="Modul Calc dengan fungsi add, dengan type annotation"><em>Modul Calc dengan fungsi add, dengan type annotation</em></p>
<p>Sekarang, mari kita panggil fungsi add tersebut di file index.re sebelumnya. Secara otomatis ketika kita membuat file baru, Reason akan menjadikan file Calc sebagai modul sehingga pemanggilannya dapat dilakukan dengan notasi titik atau <em>dot.</em></p>
<p><img src="https://cdn-images-1.medium.com/max/2240/1*caekOhKGcbdLlZrhqjqzSg.png" alt="Melakukan pemanggilan Modul Calc dan fungsi add."><em>Melakukan pemanggilan Modul Calc dan fungsi add.</em></p>
<p>Hasilnya dapat kita nikmati di console browser seperti berikut.</p>
<p><img src="https://cdn-images-1.medium.com/max/2000/1*GYlHR2jiPuxSGRHcY5wB2A.png" alt="Hasil pemanggilan fungsi add."><em>Hasil pemanggilan fungsi add.</em></p>
<p>Sekarang mari kita belajar tentang variant dan pattern matching.</p>
<h2>Variant, Record dan Pattern Matching</h2>
<p>Variant ini adalah salah satu fitur yang tidak semua bahasa pemrograman punya. JavaScript tidak memiliki fitur ini. Sederhananya, kita bisa membuat struktur data sendiri dengan menggunakan variant. Misalnya kita ingin membuat struktur data spesies yang muncul di komik Dragon Ball.</p>
<p><img src="https://cdn-images-1.medium.com/max/2000/1*nYhg9HX7er4-1ejej1IVLg.png" alt="Definisi spesies DragonBall"><em>Definisi spesies DragonBall</em></p>
<p>Kemudian jika kita ingin menciptakan karakter baru dengan spesies tertentu, kita bisa definisikan bentuknya dengan struktur data Record. Record ini mirip object di JavaScript dengan beberapa perbedaan: lebih ringan, cepat, immutable, bentuk dan jumlah <em>field</em> yang baku, harus mendefinisikan tipe datanya.</p>
<p>Jadi untuk menggunakan record kita harus mendefinisikan tipe data dan bentuknya seperti berikut.</p>
<p><img src="https://cdn-images-1.medium.com/max/2240/1*PKmOQMieB9b6lNGUqpBVpw.png" alt="Tipe Record characters."><em>Tipe Record characters.</em></p>
<p>Setelah didefinisikan bentuk dan tipe datanya barulah kita dapat menggunakan record.</p>
<p><img src="https://cdn-images-1.medium.com/max/2200/1*N25teCKUFx-S0gZHLcfNjw.png" alt="Menggunakan record Bejita dengan tipe record characters."><em>Menggunakan record Bejita dengan tipe record characters.</em></p>
<p>Dan pattern matching adalah fitur yang sangat powerful. Misalnya untuk contoh diatas, kita ingin mencocokkan apakah karakter yang kita definisikan seorang Namek, Saiya, ataupun yang lain.</p>
<p><img src="https://cdn-images-1.medium.com/max/2200/1*LuERyXDd1HHbHEsWN5utOg.png" alt="Mencocokkan berdasarkan species."><em>Mencocokkan berdasarkan species.</em></p>
<p>Namun, jika kita lihat di editor, misalnya VS Code atau vim ada peringatan bahwa pattern matching masih ada yang kurang, atau <em>pattern matching is not exhaustive enough</em>. Hal seperti ini memang diizinkan di bahasa seperti JavaScript. Tapi bahasa dengan <em>strongly typed</em> biasanya tidak memperbolehkannya. Solusinya kita harus menulis kasus untuk semua spesies. Atau, kita bisa menggunakan notasi <em>underscore</em> untuk menyatakan <em>else</em> atau spesies selain Saiyan atau Namekian.</p>
<p><img src="https://cdn-images-1.medium.com/max/2200/1*pLlJAkEbEfrdsK_xD5leww.png" alt="Support Other species"><em>Support Other species</em></p>
<h3>Binding dan Interop</h3>
<p>Seperti yang sudah dijabarkan sebelumnya, interopabilitas Reason dengan JavaScript sangat mudah. Kita bahkan bisa menuliskan sintaks JavaScript dengan bantuan bs.raw().</p>
<p><img src="https://cdn-images-1.medium.com/max/2240/1*5gpTjelFVz5Hy3IAqJ7xQQ.png" alt="Interopabilitas dengan bs.raw"><em>Interopabilitas dengan bs.raw</em></p>
<p>Kita juga bisa menulis sintaks JavaScript yang setelah dievaluasi kemudian di <em>binding</em> ke variable Reason.</p>
<p><img src="https://cdn-images-1.medium.com/max/2240/1*xqMqys9wJyGVdUmbei8q4w.png" alt="Dari JavaScript di binding ke Reason"><em>Dari JavaScript di binding ke Reason</em></p>
<p>Atau yang lebih mantap, kita bisa menggunakan fungsi di JavaScript dan kemudian di <em>binding</em> atau di <em>mapping</em> ke variable Reason.</p>
<p><img src="https://cdn-images-1.medium.com/max/2240/1*uRjDitMfTOiCAiTclrqIXQ.png" alt="Menggunakan fungsi Math.PI JavaScript dan digunakan di Reason."><em>Menggunakan fungsi Math.PI JavaScript dan digunakan di Reason.</em></p>
<h2>Kesimpulan</h2>
<p>Reason merupakan pilihan menarik karena sintaks-nya yang modern dan pilihan alat bantu yang lengkap. Keunggulan utamanya dari Reason adalah <em>type system</em> yang sangat <em>powerful</em> serta bantuan <em>type inference</em> sehingga kita tidak perlu mendefinisikan semua tipe data. Hal ini sangat membantu teman-teman yang baru belajar sehingga porsi ketikan menjadi lebih sedikit.</p>
<p>Reason dapat dikompilasi menjadi JavaScript dengan optimal dan hasilnya pun mudah dibaca, namun juga dapat dikompilasi ke <em>bytecode.</em> Proses kompilasinya cepat dan apabila terjadi kesalahan, pesan kesalahan sangat detil dan “manusiawi”.</p>
<p>Jadi, tunggu apalagi?! Tidak ada alasan lagi kan untuk tidak memilih Reason?!</p>

      ---
      <footer>
          <h5>👋 Saya Riza, co-founder 🦊 <a href="https://hacktiv8.com/" target="_blank" class="">HACKTIV8</a>, inisiator 🔥 <a href="https://deeptech.id" target="_blank" class="">DeepTech</a>, 🕸️ <a href="https://developers.google.com/community/experts/directory/profile/profile-riza-fahmi" target="_blank" class="">Google Developers Experts</a>.</h5> 
          <p class="footer">🗒️ <a href="/articles" class="color-blue">Tulisan</a> | 🎙️ <a href="/showcase" class="color-green">Karya</a> | ⚙️ <a href="/service" class="color-yellow">Service</a> | 🔬 <a href="/experiment" class="color-red">Eksperimen</a> | 🚢 <a href="/mentorship" class="color-orange">Mentorship</a></p>

      </footer>
      <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
  </body>
</html>
